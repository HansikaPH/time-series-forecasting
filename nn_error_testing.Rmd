---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

```{r}
library(ggplot2)

file="/media/hhew0002/f0df6edb-45fe-4416-8076-34757a0abceb/hhew0002/Academic/Monash University/Research Project/Codes/time-series-forecasting/datasets/text_data/Electricity/original_electricity_data_group1.csv"
tourism_dataset <- readLines(file)
tourism_dataset <- strsplit(tourism_dataset, ',')
```

```{r}
idr = 1
input_size = 15
output_size = 12
seasonality_period = 12
time_series = unlist(tourism_dataset[idr], use.names = FALSE)
time_series_log = log(as.numeric(time_series[1 : length(time_series)]) + 1)
time_series_length = length(time_series_log)

stl_result = tryCatch({
            sstl = stl(ts(time_series_log, frequency = seasonality_period), "period")
            seasonal_vect = as.numeric(sstl$time.series[, 1])
            levels_vect = as.numeric(sstl$time.series[, 2])
            values_vect = as.numeric(sstl$time.series[, 2] + sstl$time.series[, 3])# this is what we are going to work on: sum of the smooth trend and the random component (the seasonality removed)
            cbind(seasonal_vect, levels_vect, values_vect)
        }, error = function(e) {
            seasonal_vect = rep(0, length(time_series_log))#stl() may fail, and then we would go on with the seasonality vector=0
            levels_vect = time_series_log
            values_vect = time_series_log
            cbind(seasonal_vect, levels_vect, values_vect)
        })
# plotting
 df = as.data.frame(stl_result[,3])
ggplot(data=df) + geom_line(aes(x=as.numeric(row.names(df)), y=stl_result[, 3]))
```

```{r}
# needed for creating the validation windows
max_forecast_horizon = 12
level_values_validation = stl_result[input_size : (time_series_length - max_forecast_horizon), 2]
level_values_validation

val_levels_df = as.data.frame(level_values_validation)
ggplot(data=val_levels_df) + geom_line(aes(x=as.numeric(row.names(val_levels_df)), y=level_values_validation))
```

```{r}
# needed for creating the testing windows
level_values_testing = stl_result[,2]
level_values_testing
```


```{r}
# plotting level values
testing_levels_df = as.data.frame(level_values_testing)
testing_levels_df
nrow(testing_levels_df)
ggplot(data=testing_levels_df) + geom_line(aes(x=as.numeric(row.names(testing_levels_df)), y=level_values_testing))

```
```{r}
stl_result[,3]
time_series_log
#autoplot(stl_result[,3])
```

```{r}

index = 1
seasonality_period = 12
time_series_test = unlist(tourism_dataset[index], use.names = FALSE)
time_series_test = as.numeric(time_series_test[1 : length(time_series_test)])
time_series_length = length(time_series_test)
#time_series_log = log(as.numeric(time_series[1 : length(time_series)]) + 1)  
  
# read the actuals
actuals = read.csv("datasets/text_data/Electricity/electricity_results_group1.csv", header=FALSE, sep=";")
actuals = actuals[,2:ncol(actuals)]
#actuals = as.list(actuals[index])

whole_series = cbind(t(time_series_test), actuals[index,])
whole_series_log = unlist(log((whole_series + 1)))
stl_result_test = tryCatch({
            sstl_test = stl(ts(whole_series_log, frequency = seasonality_period), "period")
            seasonal_vect_test = as.numeric(sstl_test$time.series[, 1])
            levels_vect_test = as.numeric(sstl_test$time.series[, 2])
            values_vect_test = as.numeric(sstl_test$time.series[, 2] + sstl_test$time.series[, 3])# this is what we are going to work on: sum of the smooth trend and the random component (the seasonality removed)
            cbind(seasonal_vect_test, levels_vect_test, values_vect_test)
        }, error = function(e) {
            seasonal_vect_test = rep(0, length(whole_series_log))#stl() may fail, and then we would go on with the seasonality vector=0
            levels_vect_test = whole_series_log
            values_vect_test = whole_series_log
            cbind(seasonal_vect_test, levels_vect_test, values_vect_test)
        })
level_values_test = stl_result_test[,2]
test_levels_df = as.data.frame(level_values_test)
test_levels_df
data = as.data.frame(stl_result_test[,3])
data
ggplot(data=test_levels_df) + geom_line(aes(x=as.numeric(row.names(test_levels_df)), y=levels_vect_test))

```

```{r}
#actuals
forecasts
```


```{r}
# read rnn forecasts
forecasts = read.csv("results/rnn_forecasts/electricity_stacking_LSTMcell_moving_window_with_stl_decomposition_smac_cocob_without_truncated_backpropagation_with_accumulated_error_1.txt", header=FALSE)

# read txt test data
txt_test_df=read.csv(file="datasets/text_data/Electricity/moving_window/electricity_test_12i15.txt",sep = " ",header = FALSE)

actuals = read.csv("datasets/text_data/Electricity/electricity_results.csv", header=FALSE, sep=";")
actuals = actuals[,2:ncol(actuals)]
#
# # take the transpose of the dataframe
# value <- t(txt_test_df[1])
#
# indexes <- length(value) - match(unique(value), rev(value)) + 1
#
# uniqueindexes <- unique(indexes)
#
# converted_actuals_df = NULL
# # postprocess forecasts
# for(k in 1 :nrow(forecasts)){
#   #one_ts_forecasts = as.numeric(forecasts[k,])
#
#   finalindex <- uniqueindexes[k]
#   one_line_test_data = as.numeric(txt_test_df[finalindex,])
#   level_value = one_line_test_data[input_size + 3]
#   #print(paste("level:", level_value))
#
#   seasonal_values = one_line_test_data[(input_size + 4): (3 + input_size + output_size)]
#   #print(paste("seasonalit:", seasonal_values))
#   converted_actuals = (log(actuals[k,] + 1) - seasonal_values - level_value)
#   converted_actuals_df = rbind(converted_actuals_df, converted_actuals)

  #print(t(converted_actuals))
  #print(one_ts_forecasts)
  #x = cbind(converted_actuals, one_ts_forecasts)

  #one_ts_forecasts = as.data.frame(one_ts_forecasts)
  #one_ts_forecasts
  #converted_actuals = t(converted_actuals)
  #head(converted_actuals)

  #y = cbind(converted_actuals, one_ts_forecasts)


  #head(y)
  #converted_forecasts_df = one_ts_forecasts + level_value
  #ggplot(y)
#}
```

```{r}

# take the transpose of the dataframe
input_size = 15
output_size = 12
value <- t(txt_test_df[1])

indexes <- length(value) - match(unique(value), rev(value)) + 1

uniqueindexes <- unique(indexes)

converted_actuals_df = NULL
# postprocess forecasts
for(k in 1 :nrow(forecasts)){
  #one_ts_forecasts = as.numeric(forecasts[k,])

  finalindex <- uniqueindexes[k]
  one_line_test_data = as.numeric(txt_test_df[finalindex,])

  seasonal_values = one_line_test_data[(input_size + 4): (3 + input_size + output_size)]
  level_value = one_line_test_data[input_size + 3]
  converted_actuals = (log(actuals[k,] + 1) - seasonal_values - level_value)
  if(k == 1){
    converted_actuals_df = converted_actuals
  }else
  {
    converted_actuals_df = rbind(converted_actuals_df, converted_actuals)
  }

}

#ggplot(data=merge.df,aes(x=actual,y=forecasts,colour=s_index)) + geom_point(alpha=0.5) + xlim(-1,8) + ylim(-1,9)

```


```{r}
# comparison of nn errors and actual forecasts (plot)
prep.df <- as_tibble(converted_actuals_df)
names(prep.df) <- c(1:12)
prep.df %>%
   rownames_to_column('s_index') %>%
   gather(key = t, value=actual, -s_index) %>%
   mutate(t=as.numeric(t)) %>%
   arrange(s_index,t)  -> actual_conv.df

 prep_2.df <- as_tibble(forecasts)
 names(prep_2.df) <- c(1:12)
 prep_2.df %>%
   rownames_to_column('s_index') %>%
   gather(key = t, value=forecasts, -s_index) %>%
  mutate(t=as.numeric(t)) %>%
   arrange(s_index,t) -> forcat_conv.df

 actual_conv.df %>%
   inner_join(forcat_conv.df, by = c('s_index','t')) -> merge.df
 merge.df %>%
   gather(key = key,value=measurment, -s_index, -t) -> combinded.df
 head(combinded.df)

# final plot drawn by Klaus
merge.df %>% arrange(s_index,t) %>%  ggplot(data=.,aes(x=actual,y=forecasts,colour=s_index)) + geom_path() + xlim(-1,8) + ylim(-1,9) + geom_abline(slope=1)
```



```{r}
# extract the required actual or forecast
actual_idr = t(as.vector(forecasts[idr,]))

# change col names
colnames(actual_idr) = c("val")

# change col names
colnames(df) = c("val")

last_level = level_values_testing[length(level_values_testing)]
actual_whole_series = rbind(df, actual_idr + last_level)
actual_whole_series$id = seq.int(nrow(actual_whole_series))
actual_whole_series

```

```{r}
#plotting the actual whole series
ggplot(data=actual_whole_series) + geom_line(aes(x=as.numeric(row.names(actual_whole_series)), y=val))

```

```{r}
(log(1269.334 + 1) -0.392210216358047 )/8.19429630389435
#exp(0.8775979 * 8.19429630389435+ 0.392210216358047) - 1

```

